#CRUD Quiz

Use the solution to this afternoon's Property Tracker lab to answer the following questions. Please write your answers under each question, push the file to GitHub, and submit in the usual way.

#MVP Questions

In our Property Tracker application:

Q1. Where are we instantiating instances of the Property class?
  We instantiate the instances of the Property class in the file console.rb, and then inserting them into the SQL table.

Q2. Where are we defining the SQL that enables us to save the ruby Property object into the database?
  We created a database on the terminal, then in the .sql file we created the table.

Q3. In console.rb, which lines modify the database?
  Lines 20 and 21 (which insert rows into the database) and lines 23-24 (which update existing information in the database). Also line 4, which deletes all rows in the database.

Q4. Why do we not define the id of a Property object at the point we instantiate it (‘new it up’)?
  Because it is the database's responsibility to do this. If we defined the id when we instantiated the object, we would introduce a risk of error.

Q5. Where and how do we assign the id (that is generated by the database) to the ruby Property object?
  In the SQL file, when we create the table, we instruct the program to create an ID. In the property.rb file, we tell the program that there will be an id (in the initialize method), give the ability to access attributes (so, SQL can write the id) and in the save method we instruct the program to put the id in the first position.

Q6. Why do we put a guard (an if clause) on the @id attribute in the constructor?
  To prevent a nil id being added.

Q7. Why are some of the CRUD actions represented by instance methods, and others by class methods?
  The instance methods are for when we only want to affect a particular instance of the class. Useful when we know the id or other unique identifier of the object. Class methods are for when we want to impact all or several of the objects (for example delete_all)


Q8. What type of data structure is returned by calls to db.exec_prepared()? In the save method, how do we access the id from the returned data structure?
  dc.exec_prepared returns an array. We then select the 0-indexed item, which is the id.

Q9. Why do we use prepared statements when performing database operations?
To prevent SQL injection attacks. These SQL injection attacks can happen when the data that is put into one of the instance attributes is also an SQL instruction. For instance, if DELETE FROM properties was entered into one of the attributes (such as address), data could be deleted. By using a prepared statement, we can make sure that the data is entered in a particularly way, for by example by converting it to a string. This prevents SQL reading the data as an instruction.

#Extension Questions
Look at the find_by_id and find_by_address methods in the Property class.

Q10. What do they take in as their arguments?
find_by_id takes in id and find_by_address takes in address.

Q11. What are their return values?
In each case, the method returns a hash that contains all the attributes of the found property. 
